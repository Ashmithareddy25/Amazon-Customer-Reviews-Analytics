import joblib
import re
import numpy as np
import pandas as pd
import scipy.sparse as sp
from sklearn.base import BaseEstimator

# -----------------------------------------------------------
# MODEL FILE PATHS
# These point to serialized ML models saved using joblib.
# The analyzer loads:
# - Logistic Regression sentiment classifier
# - TF-IDF vectorizer for text transformation
# - Linear Regression model for rating prediction
# -----------------------------------------------------------
SENTIMENT_MODEL = "models/sentiment_model.pkl"
TFIDF_MODEL = "models/tfidf_vectorizer.pkl"
RATING_MODEL = "models/rating_regression.pkl"


class LiveReviewAnalyzer:
    """
    LiveReviewAnalyzer loads ML models and performs:
      - Sentiment prediction
      - Rating prediction
      - Combined review analysis
    It uses TF-IDF features and ensures feature-size alignment
    with trained models for safe inference.
    """

    def __init__(self):
        print("üì• Loading models...")

        # Load the sentiment classifier (Logistic Regression)
        self.sentiment_model = joblib.load(SENTIMENT_MODEL)

        # Load TF-IDF vectorizer used during model training
        self.vectorizer = joblib.load(TFIDF_MODEL)

        # Load rating prediction model (Linear Regression)
        self.rating_model = joblib.load(RATING_MODEL)

        # Expected number of features rating model was trained on.
        # Used for compatibility alignment.
        self.model_expected_features = getattr(self.rating_model, "n_features_in_", None)

        print("‚úÖ All models loaded successfully!")
        if self.model_expected_features is not None:
            print(f"‚ÑπÔ∏è Rating model expects {self.model_expected_features} features as input.")
        else:
            print("‚ö†Ô∏è Could not read rating model expected feature count (n_features_in_).")

    # -----------------------------------------------------------
    # TEXT CLEANING
    # Simple preprocessing:
    # - convert to lowercase
    # - remove punctuation and non-letters
    # -----------------------------------------------------------
    def clean_text(self, text):
        text = str(text).lower()
        text = re.sub(r"[^a-zA-Z ]", "", text)
        return text

    # -----------------------------------------------------------
    # FEATURE ALIGNMENT WORKAROUND
    # Ensures the TF-IDF vector has the SAME number of columns
    # as the rating model expects.
    #
    # Case 1: vectorizer > model ‚Üí truncate extra columns
    # Case 2: vectorizer < model ‚Üí pad zeros columns
    #
    # This prevents DimensionMismatch errors during predict().
    # -----------------------------------------------------------
    def _align_vector_to_model(self, vec):
        """
        Adjust TF-IDF sparse feature vector to match expected model size.
        This avoids failing when the vectorizer has changed vocabulary.
        Eventually, the correct fix is re-training with a consistent vectorizer.
        """
        # Ensure CSR sparse matrix
        if not sp.issparse(vec):
            vec = sp.csr_matrix(vec)

        n_vec = vec.shape[1]           # features generated by current vectorizer
        n_model = self.model_expected_features  # features model expects

        # If model feature count unavailable, skip alignment
        if n_model is None:
            print("‚ÑπÔ∏è Model expected feature count unknown. Skipping alignment.")
            return vec

        # No mismatch
        if n_vec == n_model:
            return vec

        print(f"‚ö†Ô∏è Feature mismatch detected: vectorizer -> {n_vec} features, "
              f"model -> {n_model} features.")

        # Case: vectorizer produced more features ‚Üí truncate
        if n_vec > n_model:
            print(f"‚ö†Ô∏è Truncating TF-IDF vector from {n_vec} -> {n_model} features (temporary).")
            vec_aligned = vec[:, :n_model].tocsr()
            return vec_aligned

        # Case: vectorizer produced fewer features ‚Üí pad with zeros
        pad_cols = n_model - n_vec
        print(f"‚ö†Ô∏è Padding TF-IDF vector with {pad_cols} zero columns to match model (temporary).")
        zero_pad = sp.csr_matrix((1, pad_cols))
        vec_aligned = sp.hstack([vec, zero_pad], format="csr")
        return vec_aligned

    # -----------------------------------------------------------
    # SENTIMENT PREDICTION
    # Applies TF-IDF ‚Üí logistic regression classifier
    # Returns: "positive" / "neutral" / "negative"
    # -----------------------------------------------------------
    def predict_sentiment(self, review):
        clean = self.clean_text(review)
        vec = self.vectorizer.transform([clean])
        pred = self.sentiment_model.predict(vec)[0]
        return pred

    # -----------------------------------------------------------
    # RATING PREDICTION (1‚Äì5)
    # Applies alignment workaround before predicting.
    # Returns float rating rounded to 2 decimals.
    # -----------------------------------------------------------
    def predict_rating(self, review):
        clean = self.clean_text(review)
        vec = self.vectorizer.transform([clean])

        # Align vector shape for compatibility
        vec_aligned = self._align_vector_to_model(vec)

        rating = self.rating_model.predict(vec_aligned)[0]
        return round(float(rating), 2)

    # -----------------------------------------------------------
    # FULL ANALYSIS PIPELINE
    # Runs both sentiment + rating prediction in one step.
    # -----------------------------------------------------------
    def analyze_review(self, review):
        sentiment = self.predict_sentiment(review)
        rating = self.predict_rating(review)

        return {
            "review": review,
            "sentiment": sentiment,
            "predicted_rating": rating
        }


# -----------------------------------------------------------
# COMMAND-LINE INTERFACE (CLI MODE)
# Allows users to type reviews interactively.
# -----------------------------------------------------------
if __name__ == "__main__":
    analyzer = LiveReviewAnalyzer()

    print("\nüîç Enter a review to analyze (type 'exit' to quit)\n")

    while True:
        try:
            review = input("Review: ")
        except (KeyboardInterrupt, EOFError):
            print("\nüëã Exiting analyzer...")
            break

        # Exit condition
        if review.lower() in ["exit", "quit"]:
            print("üëã Exiting analyzer...")
            break

        # Run analysis with error handling
        try:
            result = analyzer.analyze_review(review)
            print("\n----------------------------")
            print(f"üìù Review: {result['review']}")
            print(f"üí¨ Sentiment: {result['sentiment']}")
            print(f"‚≠ê Predicted Rating: {result['predicted_rating']}")
            print("----------------------------\n")

        except Exception as e:
            print("üö® Error during analysis:", str(e))
            print("Make sure you are loading the same TF-IDF vectorizer that was used during training.")
            print("As a diagnostic you can check:")

            try:
                n_vec = len(analyzer.vectorizer.get_feature_names_out())
                print(f" - Current vectorizer features: {n_vec}")
            except Exception:
                print(" - Could not read vectorizer feature names.")

            if analyzer.model_expected_features is not None:
                print(f" - Rating model expected features: {analyzer.model_expected_features}")

            break
